/**
 *  An ECB/CBC detection oracle
 *  For randomly generated AES ciphertexts guess whether they are generate with
 *  ECB or CBC method
 *
 *  Created: 22. Oct 2017.
 *  Author: Vedran Mikov
 */
#include <cstdlib>

#include <iostream>
#include <vector>
#include <fstream>

#include "../libs/mycrypto-basic.h"
#include "../libs/mycrypto-aes.h"

#include <string>

/**
 *  Given the input plaintext, function appends 5-10 bytes of data to it, randomly
 *  chooses EBC or CBC mode, randomly generate 16byte-long key and encrypts data
 *  @param plaintext Input text
 *  @return Ciphertext generated by following the procedure above
 */
string AESRandEncrypter(string const &plaintext)
{
    //  Generate length of prefix, random number between 5 and 10
    uint8_t randNum = rand() % 11;
    while (randNum < 5)
        randNum = rand() % 11;

    //  Generate prefix
    string text = AESGenerateRandString(randNum) + plaintext;

    //  Generate suffix length, random num. between 5 and 10
    randNum = rand() % 11;
    while (randNum < 5)
        randNum = rand() % 11;
    text += AESGenerateRandString(randNum);

    //  Random encryption key
    string key = AESGenerateRandString(16);

    //  Chose encryption mode
    randNum = rand() % 10;
    if (randNum < 5)
    {
        //  EBC mode
        cout<<"Encrypting in EBC mode:\n\t Key: "<<key<<endl;
        return AESEBCEncryptText(key, zeroVect, text);
    } else if (randNum >= 5)
    {
        //  CBC mode, generate IV
        string IV = AESGenerateRandString(16);

        cout<<"Encrypting in CBC mode:\n\t Key: "<<key<<"\n\t  IV: "<<IV<<endl;
        return AESCBCEncryptText(key, IV, text);
    }
}

/**
 *  For the input ciphertext encrypted with AES, function guesses which
 *  encryption types is using, EBC or CBC.
 *  @param ciphertext Input ciphertext
 *  @return String saying "EBC" or "CBC"
 */
string AESCipherOracle(string ciphertext)
{
    //  Split cipher into blocks
    vector<string>block;
    string tmp;
    for (uint32_t i = 1; i <= ciphertext.length(); i++)
    {
        tmp += ciphertext[i];
        if ((i % AES_ECB_BLOCK_SIZE) == 0)
            block.push_back(tmp), tmp = string("");
    }

    //  Check for valid length of ciphertext
    if (tmp != "")
        return "ERROR";



    return "->ECB";
}


int main()
{
    //  Initialize AES and random number generator
    InitAES128EBC();

    //  Initialization vector & encryption/decryption key
    for (uint8_t i = 0; i < 5; i++)
    {
        string ret = AESRandEncrypter("Bukachaka la la la land!");
        cout<<"\tCtxt: "<<AESCipherOracle(ret)<<endl<<endl;
    }
}

/*
    //  Split input plaintext into blocks
    string text = "This is my plaintext to encrypt with AES and then try to decrypt it back unchanged.";

    //  Open external resource file
    fstream file;
    file.open("ch10_res1.txt");
    //  Holds extracted line from file
    string b1, txtStr;

    //  Load file into a single string
    while (getline(file, b1))
        txtStr += b1;

    //  Close file, we're done
    file.close();

    //  String from file is base64-encoded, decode it to ASCII (no direct
    //  conversion available at the moment :( )
    txtStr = HexToASCII(Base64ToHex(txtStr));

    //  Initialize openSSL
    InitAES128EBC();

    //  Perform decryption
    string plainText = AESCBCDecryptText(key, iv, txtStr);

    //  Write result to file
    file.open("ch10_decrypted.out", ios::out);
    file<<"Got the following plaintext: \n\t"<<plainText<<endl;
    file.close();
    return 0;
    */
